链接库时会找不到创建的libmod2.so文件
使用命令 export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/dutian/VsCodeWorkSpace/Makefile_Turtorial/libs
可能只在一个终端中有效
此时 make，重新生成可执行文件，就可以找到libmod2.so文件了
需要在src目录下运行../../bins/**

如果从头文件运行可执行文件，则执行make clean
再执行export INSTALLATION_PATH=/home/dutian/VsCodeWorkSpace/Makefile_Turtorial
最后再执行make

make参数释义：
-L ：指定库文件（libraries）的路径
-l : 指定库文件的名称，不需要写lib前缀和.so后缀
$@ : 表示目标文件
$^ : 表示所有的依赖文件
$< : 表示第一个依赖文件
-c : 表示只编译，不链接
-o : 表示输出文件
.so : 表示共享库（Shared Object）文件的后缀
.a : 表示静态库（Static Library）文件的后缀

.o : 是目标文件（Object File）的扩展名，它们是在编译源代码文件（如 .c、.cpp 等）时生成的中间文件。在编译过程中，编译器将源代码文件转换成机器语言代码，但这些代码还不是可以直接由操作系统执行的程序。相反，它们被组织成目标文件，这些文件包含了程序的机器语言代码，但还没有被链接成可执行文件。

        目标文件通常包含以下信息：
            机器语言代码：这是源代码中函数和变量的机器语言表示。
            符号表：包含了程序中所有函数和变量的名称及其地址的列表。这些地址是临时的，因为最终的可执行文件中的地址可能会因为链接过程中的重定位而改变。
            重定位信息：这些信息用于在链接过程中将目标文件中的代码和数据放置到最终的可执行文件中的正确位置。
            调试信息（可选）：如果编译时启用了调试选项（如 -g 在 GCC 中），则目标文件中还会包含调试信息，这些信息对于调试程序非常有用。

    在链接阶段，链接器（Linker）会读取一个或多个目标文件以及任何必要的库文件，并将它们合并成一个可执行文件（在 Unix-like 系统中通常是 .out、.exe 或无扩展名的文件，在 Windows 上是 .exe 或 .dll 文件）。链接器会解决目标文件之间的符号引用，将函数调用和变量访问链接到正确的地址，并生成最终的可执行文件。
    简而言之，.o 文件是编译过程中的一个重要中间产物，它们包含了程序的机器语言代码和必要的元数据，以便在链接阶段生成最终的可执行文件。

.a ：是静态库（Static Library）文件的扩展名，它们是在链接阶段生成的。静态库是由多个目标文件（.o 文件）打包在一起，这些目标文件包含了程序的机器语言代码和必要的元数据。在链接阶段，链接器会将静态库中的目标文件合并到最终的可执行文件中，从而将静态库中的代码和数据包含到程序中。

    静态库的优点是，它们在编译时被包含到最终的可执行文件中，因此运行程序时不需要额外的库文件。这使得静态库非常适合用于嵌入式系统或需要在没有网络连接的环境中运行的程序。
    静态库的缺点是，它们可能会增加最终可执行文件的大小，因为所有的代码和数据都被包含在内。此外，如果静态库中的代码被修改，那么所有的程序都需要重新编译，因为它们都依赖于同一个静态库的副本。

    在 Unix-like 系统中，静态库通常使用 ar 命令创建，例如：
    ar rcs libexample.a file1.o file2.o
    这将创建一个名为 libexample.a 的静态库，其中包含 file1.o 和 file2.o 这两个目标文件。

.so : 是动态链接库（Shared Library）文件的扩展名，它们是在链接阶段生成的。动态链接库是由多个目标文件（.o 文件）打包在一起，这些目标文件包含了程序的机器语言代码和必要的元数据。在链接阶段，链接器会将动态链接库中的目标文件链接到最终的可执行文件中，从而将动态链接库中的代码和数据包含到程序中。

    动态链接库的优点是，它们在运行时被加载到内存中，因此可以共享相同的代码和数据。这使得动态链接库可以减小最终可执行文件的大小，因为多个程序可以共享同一个动态链接库的副本。此外，如果动态链接库中的代码被修改，只需要重新编译和链接使用该库的程序，而不需要重新编译和链接所有使用该库的程序。
    动态链接库的缺点是，它们在运行时需要额外的库文件，因此需要在运行程序的环境中提供这些库文件。此外，动态链接库可能会增加程序的启动时间，因为它们需要在运行时被加载到内存中。

    在 Unix-like 系统中，动态链接库通常使用 gcc 命令创建，例如：
    gcc -shared -o libexample.so file1.o file2.o
    这将创建一个名为 libexample.so 的动态链接库，其中包含 file1.o 和 file2.o 这两个目标文件。